# Tkinter

## Basic command and event binding

### Simple Tkinter application with the most basic command binding

```python
from tkinter import *
main_window = Tk()
count_label = Label(main_window, text="Count: 0")
count_label.grid(row=0, column=1)
count_value = 0

def increment_count():
	global count_value
	count_value += 1
	count_label.configure(text='Count: ' + str(count_value))

incr_button = Button(main_window, 
                     text = "Increment", 
                     command = increment_count)
incr_button.grid(row=0, column=0)

quit_button = Button(main_window, 
                     text = "Quit", 
                     command = main_window.destroy)
quit_button.grid(row=1, column=0)

mainloop()
```

### Simple Tkinter application passing argument to callback

```python
from tkinter import *
main_window = Tk()
count_label = Label(main_window, text="Count: 0")
count_label.grid(row=0, column=1)
count_value = 0
val_str = 'd'

def increment_count(val_str):
	global count_value
	count_value += 1
	count_label.configure(text='Count: ' + val_str + str(count_value))

incr_button = Button(main_window, 
                     text = "Increment", 
                     command = lambda: increment_count(val_str))
incr_button.grid(row=0, column=0)

quit_button = Button(main_window, 
                     text = "Quit", 
                     command = main_window.destroy)
quit_button.grid(row=1, column=0)

mainloop()
```

### Limitations of the command option

The `command` option that is available with the Button widget and a few 
other widgets is a function that can make the programming of a 
click-of-a-button event easy. Many other widgets do not provide an 
equivalent command binding option.

By default, the `command` button binds to the left-click and the space 
bar. It does not bind to the return key. Therefore, if you bind a button 
by using the `command` function, it will react to the space bar and not 
the return key. This is counter-intuitive for many users. What's worse 
is that you cannot change the binding of the `command` function easily. 
The moral is that the command binding, though a very handy tool, is not 
flexible enough when it comes to deciding your own bindings.

### Simple Tkinter application that shows the most basic event binding

```python
from tkinter import *

root = Tk()
Label(root, 
      text = 'Click at different \n locations in the frame below').pack()

def callback(event):
    print(dir(event))
    print("you clicked at", event.x, event.y)


frame = Frame(root, bg='khaki', width=130, height=80)
frame.bind("<Button-1>", callback)
frame.pack()

root.mainloop()
```

The following is a description of the preceding code:

* We bind the Frame widget to the `<Button-1>` event, which corresponds 
to the left-click. When this event occurs, it calls the callback 
function, passing an object instance as its argument.
* We define the `callback(event)` function. Note that it takes the event 
object generated by the event as an argument.
* We inspect the event object by using `dir(event)`, which returns a 
sorted list of attribute names for the event object passed to it.
* From the attributes list generated by the object, we use two 
attributes, `event.x` and `event.y`, to print the coordinates of the 
point of click.

### Simple Tkinter application that also captures keyboard events

```python
from tkinter import *

root = Tk()
Label(root, 
      text = 'Click at different \n locations in the frame below or '
             'press a key').pack()

def key(event):
    print("key pressed is", repr(event.char))

def callback(event):
    frame.focus_set()
    print(dir(event))
    print("you clicked at", event.x, event.y )


frame = Frame(root, bg='khaki', width=130, height=80)
frame.bind("<Key>", key)
frame.bind("<Button-1>", callback)
frame.pack()

root.mainloop()
```

For a good web resource on Tkinter events and bindings, 
go [here](http://effbot.org/tkinterbook/tkinter-events-and-bindings.htm).

For a complete list of event types, 
go [here](http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M7).

For a complete list of event modifiers, 
go [here](http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M6).

For a complete keysym mapping, 
go [here](https://www.tcl.tk/man/tcl8.6/TkCmd/keysyms.htm).

### Practical example of the event binding on widgets

```python
from tkinter import *

def show_event_details(event):
    print('='*50)
    print("EventName = {0}".format(str(event.type)))
    print("EventKeySymbol = {0}".format(str(event.keysym)))
    print("EventType = {0}".format(str(event.type)))
    print("EventWidgetId = {0}".format(str(event.widget)))
    print("EventCoordinate (x,y) = ({0},{1})".format(str(event.x), 
                                                     str(event.y)))
    print("Time: {0}".format(str(event.time)))


root = Tk()

button = Button(root, 
                text = "Button Bound to: \n Keyboard Enter & "
                       "Mouse Click")
button.pack(pady=5,padx=4)
button.focus_force()         	
button.bind("<Button-1>", show_event_details)
button.bind("<Return>", show_event_details)

Label(text = "Entry is Bound to Mouseclick \n, FocusIn "
             "and Keypress Event").pack()
entry = Entry(root)
entry.pack()
entry.bind("<Button-1>", show_event_details)
entry.bind("<Button-3>", show_event_details)
entry.bind("<FocusIn>", show_event_details)

alpha_num_keys = 'ABCDEFGHIGKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz123456789'
for key in alpha_num_keys:
    entry.bind("<KeyPress-{0}>".format(key), show_event_details)

keysyms = ['Alt_L', 'Alt_R','BackSpace', 'Cancel', 'Caps_Lock','Control_L',
           'Control_R','Delete', 'Down', 'End', 'Escape', 'Execute','F1',
           'F2', 'Home', 'Insert', 'Left','Linefeed','KP_0','KP_1','KP_2',
           'KP_3','KP_4','KP_5','KP_6','KP_7','KP_8','KP_9','KP_Add',
           'KP_Decimal','KP_Divide']
for i in keysyms:
    entry.bind("<KeyPress-{0}>".format(i), show_event_details)

Label(text = "Canvas Bound to Motion Event\n(Hover over the area \nto "
             "see motion event)").pack()		
canvas = Canvas(root, background='white',width=100, height=30)
canvas.pack()
canvas.bind('<Motion>', show_event_details)

Label(text="Entry Widget Bound to \n<Any KeyPress>").pack()
entry_1 = Entry(root)
entry_1.pack(pady=7)
entry_1.bind("<Any KeyPress>", show_event_details)

root.mainloop()
```

Rather than binding an event to a particular widget, you can also bind 
it to the top, level window. The syntax remains the same except that now 
you call it on the root instance of the root window like `root.bind()`.

### Simple Tkinter application that captures all keyboard events

```python
from tkinter import *

root = Tk()
Label(root, text = 'Press a key').pack()

def key(event):
    print("key pressed is", repr(event.char))

frame = Frame(root, bg='khaki', width=130, height=80)
root.bind("<Key>", key)
frame.pack()

root.mainloop()
```

### The levels of binding

* Application-level binding (root.bind, root.bind_all)
* Class-level binding (w.bind_class, my_entry.bind_class)
* Instance-level binding (w.bind)

Most keyboard and mouse events occur at the operating system level. It 
propagates hierarchically upwards from the source of the event until it 
finds a window that has the corresponding binding. The event propagation 
does not stop there. It propagates itself upwards, looking for other 
bindings from other widgets, until it reaches the root window. If it 
does reach the root window and no bindings are discovered by it, the 
event is disregarded.
